<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Submission" content="/tmp/codecheck/20052812526828179062086611371"/>
<meta name="Time" content="2020-05-28T12:52:50Z"/>
<meta name="ID" content="minheaptest"/>
<meta name="User" content="20042614307rgyb2myoe4w951vcsourllng"/>
<meta name="Problem" content="ext/2005231846e4oei51hj042oiavavy05fnk3"/>
<meta name="Elapsed" content="2076 ms"/>
<style type="text/css">
.header {font-weight: bold; font-size: 1.2em; }
.item {font-weight: bold;}
.pass {color: green;}
.fail {color: red;}
.note {color: blue; font-weight: bold;}
table.file td {padding-right: 1em; background: #FFF; }
.linenumber {color: gray;}
.footnote {font-size: 0.7em;}
table {font-size: 0.9em;}
td, th { background: #EEE; margin: 0.5em; padding: 0.25em;}
table.output td {vertical-align: top;}
div.footnotes { border-top: 1px solid gray; padding-top: 0.5em; }
</style>
<title>Report</title>
</head>
<body>
<p class="header run">Testing MinHeapTest.cpp</p>
<div class="run">
<p class="caption">Command line arguments:</p>
<pre class="output">1 2 3 4 5 6 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 8
Size = 0

PROCESS ARGS
ARG 1: Inserting 1
ARG 2: Inserting 2
ARG 3: Inserting 3
ARG 4: Inserting 4
ARG 5: Inserting 5
ARG 6: Inserting 6
ARG ?: View
tree:
       /4 
   /2 
       \5 
:1 
       /6 
   \3 
array: 1  2  3  4  5  6 
size: 6
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 6
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 5
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">6 5 4 3 2 1 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 8
Size = 0

PROCESS ARGS
ARG 6: Inserting 6
ARG 5: Inserting 5
ARG 4: Inserting 4
ARG 3: Inserting 3
ARG 2: Inserting 2
ARG 1: Inserting 1
ARG ?: View
tree:
       /6 
   /3 
       \4 
:1 
       /5 
   \2 
array: 1  3  2  6  4  5 
size: 6
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 6
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 5
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">3 5 2 1 6 4 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 8
Size = 0

PROCESS ARGS
ARG 3: Inserting 3
ARG 5: Inserting 5
ARG 2: Inserting 2
ARG 1: Inserting 1
ARG 6: Inserting 6
ARG 4: Inserting 4
ARG ?: View
tree:
       /5 
   /2 
       \6 
:1 
       /4 
   \3 
array: 1  2  3  5  6  4 
size: 6
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 6
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 5
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">5 6 3 1 4 2 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 8
Size = 0

PROCESS ARGS
ARG 5: Inserting 5
ARG 6: Inserting 6
ARG 3: Inserting 3
ARG 1: Inserting 1
ARG 4: Inserting 4
ARG 2: Inserting 2
ARG ?: View
tree:
       /6 
   /3 
       \4 
:1 
       /5 
   \2 
array: 1  3  2  6  4  5 
size: 6
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 6
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 5
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">5 6 3 ? 1 ? 4 ? 2 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 11
Size = 0

PROCESS ARGS
ARG 5: Inserting 5
ARG 6: Inserting 6
ARG 3: Inserting 3
ARG ?: View
tree:
   /6 
:3 
   \5 
array: 3  6  5 
size: 3
Check: OK
ARG 1: Inserting 1
ARG ?: View
tree:
       /6 
   /3 
:1 
   \5 
array: 1  3  5  6 
size: 4
Check: OK
ARG 4: Inserting 4
ARG ?: View
tree:
       /6 
   /3 
       \4 
:1 
   \5 
array: 1  3  5  6  4 
size: 5
Check: OK
ARG 2: Inserting 2
ARG ?: View
tree:
       /6 
   /3 
       \4 
:1 
       /5 
   \2 
array: 1  3  2  6  4  5 
size: 6
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 6
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 5
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">8 4 9 4 3 1 10 2 5 7 11 6 ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 14
Size = 0

PROCESS ARGS
ARG 8: Inserting 8
ARG 4: Inserting 4
ARG 9: Inserting 9
ARG 4: Inserting 4
ARG 3: Inserting 3
ARG 1: Inserting 1
ARG 10: Inserting 10
ARG 2: Inserting 2
ARG 5: Inserting 5
ARG 7: Inserting 7
ARG 11: Inserting 11
ARG 6: Inserting 6
ARG ?: View
tree:
           /8 
       /4 
           \5 
   /2 
           /7 
       \4 
           \11 
:1 
           /9 
       /6 
   \3 
       \10 
array: 1  2  3  4  4  6  10  8  5  7  11  9 
size: 12
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 12
Min = 1

REMOVING REMAINING ITEMS
Removing 1
Removing 2
Removing 3
Removing 4
Removing 4
Removing 5
Removing 6
Removing 7
Removing 8
Removing 9
Removing 10
Removing 11

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">5 6 3 ? - ? 1 ? 4 ? 2 ? - ? - ? - ? - ?</pre>
<pre class="output">CREATE AN EMPTY HEAP
Capacity = 21
Size = 0

PROCESS ARGS
ARG 5: Inserting 5
ARG 6: Inserting 6
ARG 3: Inserting 3
ARG ?: View
tree:
   /6 
:3 
   \5 
array: 3  6  5 
size: 3
Check: OK
ARG -: Removing 3
ARG ?: View
tree:
   /6 
:5 
array: 5  6 
size: 2
Check: OK
ARG 1: Inserting 1
ARG ?: View
tree:
   /6 
:1 
   \5 
array: 1  6  5 
size: 3
Check: OK
ARG 4: Inserting 4
ARG ?: View
tree:
       /6 
   /4 
:1 
   \5 
array: 1  4  5  6 
size: 4
Check: OK
ARG 2: Inserting 2
ARG ?: View
tree:
       /6 
   /2 
       \4 
:1 
   \5 
array: 1  2  5  6  4 
size: 5
Check: OK
ARG -: Removing 1
ARG ?: View
tree:
       /6 
   /4 
:2 
   \5 
array: 2  4  5  6 
size: 4
Check: OK
ARG -: Removing 2
ARG ?: View
tree:
   /6 
:4 
   \5 
array: 4  6  5 
size: 3
Check: OK
ARG -: Removing 4
ARG ?: View
tree:
   /6 
:5 
array: 5  6 
size: 2
Check: OK
ARG -: Removing 5
ARG ?: View
tree:
:6 
array: 6 
size: 1
Check: OK

FINISHED ARGS

QUERY FUNCTIONS
Size = 1
Min = 6

REMOVING REMAINING ITEMS
Removing 6

FINISHED REMOVING
tree:
array:
size: 0
<b></b>
</pre>
<span class="pass">pass </span></div>
<p class="header studentFiles">Submitted files</p>
<div class="studentFiles">
<p class="caption">MinHeap.cpp:</p>
<pre>//NMEC: 93097
//NOME: João Gameiro
//
// João Manuel Rodrigues, AlgC, May 2020
// Joaquim Madeira, AlgC, May 2020
//
// Binary Min Heap storing pointers to generic items.
//

//// PROCURE ... E COMPLETE ////

#include "MinHeap.h"

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//
// A binary or 2-way heap is a complete tree stored in an array.
//
// +-------------------------------------------------------------------------------+
// |                                       0                                       |
// +---------------------------------------+---------------------------------------+
// |                   1                   |                   2                   |
// +-------------------+-------------------+-------------------+-------------------+
// |         3         |         4         |         5         |         6         |
// +---------+---------+---------+---------+---------+---------+---------+---------+
// |    7    |    8    |    9    |   10    |   11    |   12    |   13    |   14    |
// +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
// | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |
// +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
//
// The descendents of node k are 2*k+1 and 2*k+2.
//
// The value of each node cannot be larger that those of its descendents.
//

// The heap data structure
struct _Heap {
   void** array;
   int capacity;
   int size;
   compFunc compare;
   printFunc print;
};

MinHeap* MinHeapCreate(int capacity, compFunc compF, printFunc printF) {
   MinHeap* h = (MinHeap*)malloc(sizeof(MinHeap));  // alloc heap header
   if (h == NULL) abort();
   h-&gt;array = (void**)malloc(capacity*sizeof(void*));  // alloc array
   if (h-&gt;array == NULL) {
      free(h);
      abort();
   }
   h-&gt;capacity = capacity;
   h-&gt;size = 0;
   h-&gt;compare = compF;
   h-&gt;print = printF;
   return h;
}

void MinHeapDestroy(MinHeap** pph) {
   MinHeap* ph = *pph;
   if (ph == NULL) return;
   free(ph-&gt;array);
   free(ph);
   *pph = NULL;
}


int MinHeapCapacity(MinHeap* ph) { return ph-&gt;capacity; }

int MinHeapSize(MinHeap* ph) { return ph-&gt;size; }

int MinHeapIsEmpty(MinHeap* ph) { return ph-&gt;size == 0; }

int MinHeapIsFull(MinHeap* ph) { return ph-&gt;size == ph-&gt;capacity; }

void* MinHeapGetMin(MinHeap* ph) {
   assert( !MinHeapIsEmpty(ph) );
   return ph-&gt;array[0];
}

// Internal functions

// n is the index of a node (n in [0, size[).
// _child(n, 1) is the index of the first _child of node n, if &lt; size.
// _child(n, 2) is the index of the second _child of node n, if &lt; size.
static inline int _child(int n, int c) {
 return 2*n+c;
}

// _parent(n) is the index of the _parent node of node n, if &gt;=0.
static inline int _parent(int n) {
 assert(n&gt;0);
 return (n-1)/2;
}

// Insert the item into the heap
void MinHeapInsert(MinHeap* ph, void* item) {
   assert( !MinHeapIsFull(ph) );
   // start at the first vacant spot (just after the last occupied node)
   int n = ph-&gt;size;
   while (n &gt; 0) {
      int p = _parent(n);
      
      // if item not less than _parent, then we've found the right spot!
      if (ph-&gt;compare(item, ph-&gt;array[p]) &gt; 0) break;
      
      // otherwise, move up the item at node p to open up space for new item
      ph-&gt;array[n] = ph-&gt;array[p];
      
      n = p;  // p is the new vacant spot
   }
   ph-&gt;array[n] = item;  // store item at node n
   ph-&gt;size++;
}

// Remove the Min item
void MinHeapRemoveMin(MinHeap* ph) {
   assert( !MinHeapIsEmpty(ph) );
   
   ph-&gt;size--; // NOTE: we're decreasing the size first!
   int n = 0;  // the just emptied spot... must fill it with smallest child
   while (1) {
      int min = _child(n,1);      // first _child (might not exist)
      if (!(min &lt; ph-&gt;size)) break;  // if no second _child, stop looking
   
      // if second _child is smaller, choose it
      if (ph-&gt;compare(ph-&gt;array[min], ph-&gt;array[_child(n, 2)]) &gt; 0) 
         min = _child(n, 2);
   
      // if smallest _child is not smaller than last, stop looking
      if (!(ph-&gt;compare(ph-&gt;array[min], ph-&gt;array[ph-&gt;size]) &lt; 0)) break;
   
      // move smallest _child down to fill empty _parent spot
      ph-&gt;array[n] = ph-&gt;array[min];
      
      n = min;     // now, the smallest _child spot was just emptied!
   }
   // move last element to emptied spot
   ph-&gt;array[n] = ph-&gt;array[ph-&gt;size];
   ph-&gt;array[ph-&gt;size] = NULL;    // mark last element as vacant
}

// Check the (min-)heap property (the heap invariant):
//    Each node must be &lt;= than each of its children.
// Equivalently (but easier):
//    Each node must be &gt;= its parent.
int MinHeapCheck(MinHeap* ph) {
   // For each node other than root: compare with its parent
   for (int n = 1; n &lt; ph-&gt;size; n++) {
      int p = _parent(n);
      if (ph-&gt;compare(ph-&gt;array[n], ph-&gt;array[p]) &lt; 0) return 0;
   }
   return 1; 
}

// Visualize the heap items as a tree
static void _HeapView(MinHeap* ph, int level, const char* edge, int root) {
   if (root &lt; ph-&gt;size) {
      _HeapView(ph, level+1, "/", _child(root,1));
      printf("%*s", 4*level, edge);
      ph-&gt;print(ph-&gt;array[root]);
      printf("\n");
      _HeapView(ph, level+1, "\\", _child(root,2));
   }
}

// Visualize the heap both as a tree and as an array.
void MinHeapView(MinHeap* ph) {
   printf("tree:\n");
   _HeapView(ph, 0, ":", 0);  // : marks the root
   printf("array:");
   for (int i = 0; i &lt; ph-&gt;size; i++) {
      printf(" ");
      ph-&gt;print(ph-&gt;array[i]);
   }
   printf("\nsize: %d\n", ph-&gt;size);
}
</pre>
<p class="caption">MinHeapTest.cpp:</p>
<pre>//
// João Manuel Rodrigues, AlgC, May 2020
// Joaquim Madeira, AlgC, May 2020
//
// TESTING the TAD MinHeap implementation
//

// This program accepts multiple arguments.
// If the argument is:
// a number : it is inserted into a min-heap.
//    -     : the first (minimum) item is removed from the head
//    ?     : the heap content is shown, both in tree form and array form.
//
// Try the arguments below.


#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include "MinHeap.h"

// Storing pointers to integers

// The comparator for integer items

int comparator(const void* p1, const void* p2) {
   int d = *(int*)p1 - *(int*)p2;
   return (d &gt; 0) - (d &lt; 0);
}

// The printer for integer items

void printer(void* p) { printf("%d ", *(int*)p); }

int main(int argc, char* argv[]) {

   printf("CREATE AN EMPTY HEAP\n");
   // with capacity for at most argc items
   MinHeap* h1 = MinHeapCreate(argc, comparator, printer);
   printf("Capacity = %d\n", MinHeapCapacity(h1));
   printf("Size = %d\n", MinHeapSize(h1));

   printf("\nPROCESS ARGS\n");
   for (int i = 1; i &lt; argc; i++) {
      int* aux;
      char* arg = argv[i];
      printf("ARG %s: ", arg);
      switch (arg[0]) {
      case '?':  // View and Check
         printf("View\n");
         MinHeapView(h1);  // for debugging
         printf("Check: %s\n", MinHeapCheck(h1)? "OK": "ERROR");
         break;
      case '-':
         aux = (int*)MinHeapGetMin(h1);
         printf("Removing %d\n", *aux);
         MinHeapRemoveMin(h1);
         free(aux);
         break;
      default:  // assume it's an item to insert
         aux = (int*)malloc(sizeof(*aux));
         *aux = atoi(arg);
         printf("Inserting %d\n", *aux);
         MinHeapInsert(h1, aux);
      }
   }
   printf("\nFINISHED ARGS\n");
   
   printf("\nQUERY FUNCTIONS\n");
   printf("Size = %d\n", MinHeapSize(h1));
   printf("Min = %d\n", *((int*)MinHeapGetMin(h1)));

   printf("\nREMOVING REMAINING ITEMS\n");
   while (!MinHeapIsEmpty(h1)) {
      int* aux = (int*)MinHeapGetMin(h1);
      printf("Removing %d\n", *aux);
      MinHeapRemoveMin(h1);
      free(aux);
   }
   printf("\nFINISHED REMOVING\n");
   MinHeapView(h1);

   MinHeapDestroy(&amp;h1);

   return 0;
}
</pre>
</div>
<p class="header providedFiles">Provided files</p>
<div class="providedFiles">
<p class="caption">MinHeap.h:</p>
<pre>//
// João Manuel Rodrigues, AlgC, May 2020
// Joaquim Madeira, AlgC, May 2020
//
// Binary Min Heap storing pointers to generic items.
//

#ifndef _MinHeap_
#define _MinHeap_

// The type for MinHeap structures
typedef struct _Heap MinHeap;

// The type for item comparator functions
typedef int (*compFunc)(const void* p1, const void* p2);

// The type for item printer functions
typedef void (*printFunc)(void* p);


// CREATE/DESTROY

MinHeap* MinHeapCreate(int capacity, compFunc compF, printFunc printF) ;

void MinHeapDestroy(MinHeap** pph) ;

// GETTERS

int MinHeapCapacity(MinHeap* ph) ;

int MinHeapSize(MinHeap* ph) ;

int MinHeapIsEmpty(MinHeap* ph) ;

int MinHeapIsFull(MinHeap* ph) ;

void* MinHeapGetMin(MinHeap* ph) ;

// MODIFY

void MinHeapInsert(MinHeap* ph, void* item) ;

void MinHeapRemoveMin(MinHeap* ph) ;

// CHECK/VIEW

int MinHeapCheck(MinHeap* ph) ;

void MinHeapView(MinHeap* ph) ;

#endif
</pre>
</div>
<p class="header score">Score</p>
<div class="score">
<p class="score">7/7</p>
</div>
<div class="footnotes"><div class="footnote">2020-05-28T12:52:50Z</div>
</div>
</body></html>
