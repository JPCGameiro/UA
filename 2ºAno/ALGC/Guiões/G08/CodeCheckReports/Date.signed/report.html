<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Submission" content="/tmp/codecheck/20050922174755852664470770611"/>
<meta name="Time" content="2020-05-09T22:17:11Z"/>
<meta name="ID" content="Date"/>
<meta name="User" content="20042614307rgyb2myoe4w951vcsourllng"/>
<meta name="Problem" content="ext/20042812243kltunl3o74c2gq9fx4j0b4j7"/>
<meta name="Elapsed" content="4060 ms"/>
<style type="text/css">
.header {font-weight: bold; font-size: 1.2em; }
.item {font-weight: bold;}
.pass {color: green;}
.fail {color: red;}
.note {color: blue; font-weight: bold;}
table.file td {padding-right: 1em; background: #FFF; }
.linenumber {color: gray;}
.footnote {font-size: 0.7em;}
table {font-size: 0.9em;}
td, th { background: #EEE; margin: 0.5em; padding: 0.25em;}
table.output td {vertical-align: top;}
div.footnotes { border-top: 1px solid gray; padding-top: 0.5em; }
</style>
<title>Report</title>
</head>
<body>
<p class="header run">Testing TAD2Test.cpp</p>
<div class="run">
<p class="caption">Command line arguments:</p>
<pre class="output">1</pre>
<pre class="output">
1) Create DateTimes---
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">2</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">3</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">4</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">5</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">6</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">7</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0

7) SchedulingSequenceGet---
idx -&gt; 0
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
idx -&gt; 1
SchedulingSequenceGet(ss1, idx) -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">8</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0

7) SchedulingSequenceGet---
idx -&gt; 0
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
idx -&gt; 1
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
idx -&gt; 2
SchedulingSequenceGet(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

8) SchedulingSequencePop---
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">9</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0

7) SchedulingSequenceGet---
idx -&gt; 0
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
idx -&gt; 1
SchedulingSequenceGet(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

8) SchedulingSequencePop---
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">10</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0

7) SchedulingSequenceGet---
idx -&gt; 0
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
idx -&gt; 1
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
idx -&gt; 2
SchedulingSequenceGet(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

8) SchedulingSequencePop---
idx -&gt; 2
SchedulingSequencePop(ss1, idx) -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
<b></b>
</pre>
<span class="pass">pass </span><p class="caption">Command line arguments:</p>
<pre class="output">11</pre>
<pre class="output">
1) Create DateTimes---

2) DateTimeCompare---
dt[i]              	dt[j]              	cmp
2019-12-30 23:00:00	2019-12-30 14:00:00	+
2019-12-30 23:00:00	2020-01-01 11:00:00	-
2019-12-30 23:00:00	2020-02-29 20:00:00	-
2020-01-01 11:00:00	2019-12-30 14:00:00	+
2020-01-01 11:00:00	2020-01-01 11:00:00	0
2020-01-01 11:00:00	2020-02-29 20:00:00	-
2020-02-29 08:00:00	2019-12-30 14:00:00	+
2020-02-29 08:00:00	2020-01-01 11:00:00	+
2020-02-29 08:00:00	2020-02-29 20:00:00	-

3) TimeIntervalCreate---
ti[i] -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
ti[i] -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
ti[i] -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
ti[i] -&gt; [2019-12-31 09:00:00, 2020-01-01 18:00:00[(3-Férias fim-de-ano)
ti[i] -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
ti[i] -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
ti[i] -&gt; [2020-02-28 20:00:00, 2020-03-01 08:00:00[(6-Maratona TV)

4) TimeIntervalCompare/Overlaps/Contains---
ti[i]         	ti[j]         	cmp	ovr	cnt
0-Passeio Serr	1-Compras fim-	-	0	0
0-Passeio Serr	3-Férias fim-	-	0	0
0-Passeio Serr	5-Telefonar pr	-	0	0
2-Rave fim-de-	1-Compras fim-	+	0	0
2-Rave fim-de-	3-Férias fim-	0	1	0
2-Rave fim-de-	5-Telefonar pr	-	0	0
4-Estudar AlgC	1-Compras fim-	+	0	0
4-Estudar AlgC	3-Férias fim-	0	1	0
4-Estudar AlgC	5-Telefonar pr	-	0	0
6-Maratona TV	1-Compras fim-	+	0	0
6-Maratona TV	3-Férias fim-	+	0	0
6-Maratona TV	5-Telefonar pr	0	1	1

5) SchedulingSequenceCreate---
ss1 != NULL -&gt; 1
ss1-&gt;size -&gt; 0
ss1-&gt;capacity -&gt; 7

6) SchedulingSequenceAdd---
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 0
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 1
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 2
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 1
i -&gt; 6
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 3
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 4
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0
i -&gt; 5
suc = SchedulingSequenceAdd(ss1, ti[i]) -&gt; 0

7) SchedulingSequenceGet---
idx -&gt; 0
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
idx -&gt; 1
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
idx -&gt; 2
SchedulingSequenceGet(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
idx -&gt; 3
SchedulingSequenceGet(ss1, idx) -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
idx -&gt; 4
SchedulingSequenceGet(ss1, idx) -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)

8) SchedulingSequencePop---
idx -&gt; 4
SchedulingSequencePop(ss1, idx) -&gt; [2020-02-29 20:00:00, 2020-02-29 20:00:00[(5-Telefonar primo)
idx -&gt; 1
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-31 09:00:00, 2019-12-31 12:00:00[(1-Compras fim-de-ano)
idx -&gt; 2
SchedulingSequencePop(ss1, idx) -&gt; [2020-01-01 11:00:00, 2020-02-29 08:00:00[(4-Estudar AlgC)
idx -&gt; 1
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-31 12:00:00, 2020-01-01 11:00:00[(2-Rave fim-de-ano)
idx -&gt; 0
SchedulingSequencePop(ss1, idx) -&gt; [2019-12-30 14:00:00, 2019-12-30 23:00:00[(0-Passeio Serra)
<b></b>
</pre>
<span class="pass">pass </span></div>
<p class="header studentFiles">Submitted files</p>
<div class="studentFiles">
<p class="caption">Date.cpp:</p>
<pre>#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "Date.h"

const Date DateMIN = {0, 1, 1};
const Date DateMAX = {9999, 12, 31};

// Check if a yy,mm,dd tuple forms a valid date.
// (This would be a public static method in Java.)
int DateIsValid(int yy, int mm, int dd) {
  return (DateMIN.year)&lt;=yy &amp;&amp; yy&lt;=(DateMAX.year) &amp;&amp;
         1&lt;=mm &amp;&amp; mm&lt;=12 &amp;&amp;
         1&lt;=dd &amp;&amp; dd&lt;=DateDaysInMonth(yy, mm);
}

// Function to test desired internal invariant for valid Date values:
// the Date should contain valid year,month,day fields.
static int invariant(Date* d) {
  return DateIsValid(d-&gt;year, d-&gt;month, d-&gt;day);
}


// Alocate and store a date given by yy, mm, dd integers.
// (yy, mm, dd) are required to form a valid date.
// Returns the pointer to the new date structure,
// or NULL if allocation fails.
Date* DateCreate(int yy, int mm, int dd) {
  assert( DateIsValid(yy, mm, dd) );
  //SOLUTION
  Date* d = (Date*) malloc(sizeof(*d));
  if (d == NULL) return d;
  d-&gt;year = (uint16_t)yy;
  d-&gt;month = (uint8_t)mm;
  d-&gt;day = (uint8_t)dd;
  assert( invariant(d) );   // check invariant
  return d;
}

// Free the memory pointed to by *pd and invalidate *pd contents.
// Precondition: *pd must not be NULL.
// Postcondition: *pd is set to NULL.
void DateDestroy(Date* *pd) {
  assert(*pd != NULL);
  //SOLUTION
  free(*pd);
  *pd = NULL;
}

// table of month lengths in common and leap years
static const uint8_t monthLength[][12] = {
  {31,28,31,30,31,30,31,31,30,31,30,31},
  {31,29,31,30,31,30,31,31,30,31,30,31}
};

int DateDaysInMonth(int yy, int mm) {
  int isLeap = DateIsLeapYear(yy);
  return monthLength[isLeap][mm-1];
}

int DateIsLeapYear(int yy) {
  return (yy%4==0 &amp;&amp; yy%100!=0) || yy%400==0;
}

// Compare dates a and b.
// Return an integer &gt;0 if a&gt;b, 0 if a==b and &lt;0 if a&lt;b.
int DateCompare(const Date* a, const Date* b) {
  //SOLUTION
  int r = (int)a-&gt;year - (int)b-&gt;year;
  if (r!=0) return r;
  r = (int)a-&gt;month - (int)b-&gt;month;
  if (r!=0) return r;
  r = (int)a-&gt;day - (int)b-&gt;day;
  return r;
}

// Increment date.
// Precondition: d must precede DateMAX.
void DateIncr(Date* d) {
  assert( DateCompare(d, &amp;DateMAX) &lt; 0 );  // d must precede MAX!
  //SOLUTION
  if ((int)d-&gt;day &lt; DateDaysInMonth((int)(d-&gt;year), (int)(d-&gt;month))) {
    d-&gt;day++;
  } else {
    d-&gt;day = 1;
    if ((int)d-&gt;month &lt; 12) {
      d-&gt;month++;
    } else {
      d-&gt;month = 1;
      d-&gt;year++;
    }
  }
  assert( invariant(d) );   // check invariant
}

// Decrement date.
// Precondition: d must succeed DateMIN.
void DateDecr(Date* d) {
  assert( DateCompare(d, &amp;DateMIN) &gt; 0 );  // d must succeed MIN!
  //SOLUTION
  if ((int)d-&gt;day &gt; 1) {
    d-&gt;day--;
  } else {
    // decrMonth
    if ((int)d-&gt;month &gt; 1) {
      d-&gt;month--;
    } else {
      d-&gt;year--;
      d-&gt;month = (uint8_t)12;
    }
    d-&gt;day = DateDaysInMonth((int)(d-&gt;year), (int)(d-&gt;month));
  }
  assert( invariant(d) );   // check invariant
}

//static char* monthNames[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
static char strBuffer[64];

static char* fmts[] = {
  (char*)"%04d-%02d-%02d",  // YMD
  (char*)"%3$02d/%2$02d/%1$04d", // DMY
  (char*)"%2$02d/%3$02d/%1$04d", // MDY
};

// Return a formatted string representation of date d.
// Careful: the string buffer will be overwritten by the next call.
// You should strcpy or strdup the result if you need persistence!
char* DateFormat(const Date* d, int FMT) {
  if (d==NULL)
    snprintf(strBuffer, sizeof(strBuffer), "NULL");
  else
    snprintf(strBuffer, sizeof(strBuffer), fmts[FMT], d-&gt;year, d-&gt;month, d-&gt;day);
  return strBuffer;
}

// Parse str acording to format and return NEW Date,
// or NULL if invalid or memory error.
Date* DateParse(const char* str, int FMT) {
  int yy, mm, dd;
  int n = sscanf(str, fmts[FMT], &amp;yy, &amp;mm, &amp;dd);
  Date* d = NULL;
  if (n==3 &amp;&amp; DateIsValid(yy, mm, dd)) {
    d = DateCreate(yy, mm, dd);
  }
  return d;
}
</pre>
<p class="caption">DateTime.cpp:</p>
<pre>//NMEC: 93097
//NOME: João Gameiro

// Complete the functions (marked by ...)
// so that it passes all tests in DateTimeTest.

#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "DateTime.h"

// You may add auxiliary definitions and declarations here, if you need to.





// Check if given arguments would form a valid DateTime.
// A DateTime is valid iff both the date part and the time part are valid.
int DateTimeIsValid(int yy, int mm, int dd, int h, int m, int s) {
  return DateIsValid(yy, mm, dd) &amp; TimeIsValid(h, m, s);
}

// Allocate an initialize a DateTime instance.
// Return the pointer to the created instance or NULL if an error occurs.
DateTime* DateTimeCreate(int yy, int mm, int dd, int h, int m, int s) {
  assert(DateTimeIsValid(yy, mm, dd, h, m, s));
  DateTime* d = (DateTime*) malloc(sizeof(*d));
  if(d==NULL) return d;   
  Date* date = DateCreate(yy, mm, dd);
  d-&gt;date = *date;
  DateDestroy(&amp;date);
  d-&gt;time = TimeCreate(h, m, s);
  return d;

}

// Free a DateTime instance and invalidate its pointer.
void DateTimeDestroy(DateTime **pdt) {
  free(*pdt);
  *pdt = NULL;
}

// Compare datetimes a and b.
// Return an integer &gt;0 if a&gt;b, 0 if a==b and &lt;0 if a&lt;b.
int DateTimeCompare(DateTime *a, DateTime *b) {
  // KEEP IT SIMPLE.  Call the compare functions in Date and Time!
  if(DateCompare(&amp;a-&gt;date, &amp;b-&gt;date)==0)
    return TimeCompare(a-&gt;time, b-&gt;time);
  else
    return DateCompare(&amp;(a-&gt;date), &amp;(b-&gt;date));
}

// Temporary buffer for DateTimeFormat output.
static char buf[64];  // 20 should suffice

// Return *dt as a formatted string.
// The string is returned in a shared buffer, which is overwritten in each call!
char *DateTimeFormat(const DateTime *dt) {
  if (dt==NULL)
    snprintf(buf, sizeof(buf), "NULL");
  else {
    char *sd = DateFormat(&amp;(dt-&gt;date), YMD);
    char *st = TimeFormat(dt-&gt;time);
    sprintf(buf, "%s %s", sd, st);
  }
  return buf;
}

// Parse a properly formatted string and create a DateTime instance.
DateTime *DateTimeParse(char *str) {
  DateTime * dt = NULL;
  Date *d = DateParse(str, YMD);
  if (d != NULL) {
    dt = DateTimeCreate(d-&gt;year, d-&gt;month, d-&gt;day, 0, 0, 0);
    DateDestroy(&amp;d);  // not needed any more
    char *sep = strchr(str, ' '); // find date and time separator
    if (dt != NULL &amp;&amp; sep != NULL) {  // the time part is optional
      Time t = TimeParse(sep+1);
      if (t != TimeERR) {
        dt-&gt;time = t;
      }
    }
  }
  return dt;
}
</pre>
<p class="caption">SchedulingSequence.cpp:</p>
<pre>//NMEC: 93097
//NOME: João Gameiro

// Complete the functions (marked by ...)
// so that it passes all tests in DateTimeTest.

#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "SchedulingSequence.h"

// You may add auxiliary definitions and declarations here, if you need to.

void exchange(TimeInterval *p0, TimeInterval *p1){
  TimeInterval tmp = *p0;
  *p0 = *p1;
  *p1 = tmp;
}


// Create a SchedulingSequence capable of storing up to (capacity) intervals.
SchedulingSequence* SchedulingSequenceCreate(int capacity) {
  assert(capacity &gt;= 0);
  // You must allocate space for the struct and for the intervals array!
  SchedulingSequence* s = (SchedulingSequence*)malloc(sizeof(SchedulingSequence));
  if(s==NULL) return NULL;
  s-&gt;capacity = capacity;
  s-&gt;size = 0;
  s-&gt;intervals = (TimeInterval**)malloc(capacity * sizeof(TimeInterval*));
  return s;

}

// Destroy SchedulingSequence *pss
void SchedulingSequenceDestroy(SchedulingSequence **pss) {
  assert(*pss != NULL);
  free((*pss)-&gt;intervals);
  free(*pss);
  *pss = NULL; 

}

int SchedulingSequenceIsEmpty(SchedulingSequence *ss) {
  return ss-&gt;size == 0;
}

int SchedulingSequenceIsFull(SchedulingSequence *ss) {
  return ss-&gt;size == ss-&gt;capacity;
}

// Add interval *ti to *ss.
// Return true on success,
// return false if *ti overlaps any of the intervals in *ss.
int SchedulingSequenceAdd(SchedulingSequence *ss, TimeInterval *ti) {
  assert(!SchedulingSequenceIsFull(ss));
  if(ss-&gt;size == 0){
    ss-&gt;intervals[ss-&gt;size] = ti;
    ss-&gt;size++;
    return 1;
  }
  
  int i;
  for(i=0;i&lt;ss-&gt;size;i++){
    if(TimeIntervalOverlaps(ss-&gt;intervals[i], ti)==1)
      return 0;
    if(TimeIntervalCompare(ss-&gt;intervals[i], ti) &gt;= 0)
      break;  
  }
  ss-&gt;intervals[ss-&gt;size] = ti;
  ss-&gt;size++;

  for(int j=ss-&gt;size-1;j&gt;i;j--)
    exchange(ss-&gt;intervals[j-1], ss-&gt;intervals[j]);
  return 1;

}

// Get the interval at position (idx) of *ss.
// idx=0 is the first position idx=ss-&gt;size-1 is the last position.
// Precondition: 0 &lt;= idx &lt; ss-&gt;size.
TimeInterval *SchedulingSequenceGet(SchedulingSequence *ss, int idx) {
  assert (0 &lt;= idx &amp;&amp; idx &lt; ss-&gt;size);
  return ss-&gt;intervals[idx];

}

// Remove the interval at position (idx) of *ss, and return it.
// idx=0 is the first position idx=ss-&gt;size-1 is the last position.
// Precondition: 0 &lt;= idx &lt; ss-&gt;size.
TimeInterval *SchedulingSequencePop(SchedulingSequence *ss, int idx) {
  assert (0 &lt;= idx &amp;&amp; idx &lt; ss-&gt;size);
  // This implies !SchedulingSequenceIsEmpty(ss).
  TimeInterval *aux = ss-&gt;intervals[idx];
  for(int i=idx;i&lt;ss-&gt;size-1;i++)
    ss-&gt;intervals[i] = ss-&gt;intervals[i+1];
  ss-&gt;size--;
  return aux;

}

// You may add auxiliary definitions and declarations here, if you need to.



</pre>
<p class="caption">Time.cpp:</p>
<pre>// The Time data type represents times in a 24-hour clock.
//
// The times are actually stored as a single integer:
// the number of seconds elapsed since the start of the day.
//
// But the abstract data type includes constructors and getter functions
// that interpret times as (Hour, Minute, Second) tuples.

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include "Time.h"

// The number of seconds in a day
#define TimeFULLDAY ((Time)24*60*60)

// Constants
const Time TimeMIN = (Time)0;               // Smallest valid time value
const Time TimeMAX = (Time)(TimeFULLDAY-1); // Largest valid time value

const Time TimeERR = (Time)(-1);  // Invalid time value to indicate errors


// Function to test desired internal invariant for valid Time values:
// the time should be within allowed MIN and MAX.
static int invariant(Time t) {
  return TimeMIN &lt;= t &amp;&amp; t &lt;= TimeMAX;
}

// Return a Time value corresponding to hh:mm:ss.
// Note that a Time is actually just an integer
// that stores the total number of seconds since midnight.
Time TimeCreate(int hh, int mm, int ss) {
  assert( TimeIsValid(hh, mm, ss) );
  //SOLUTION
  Time t = (Time)(((hh*60)+mm)*60+ss);
  assert( invariant(t) );  // constructor must ensure the invariant!
  return t;
}

// Check if a (hh, mm, ss) tuple forms a valid time-of-day.
// (May be used to check compliance before calling TimeCreate, for example.)
int TimeIsValid(int hh, int mm, int ss) {
  return 0&lt;=hh &amp;&amp; hh&lt;24 &amp;&amp;
         0&lt;=mm &amp;&amp; mm&lt;60 &amp;&amp;
         0&lt;=ss &amp;&amp; ss&lt;60;
}

// Getters

int TimeGetHH(Time t) {
  //SOLUTION
  return (int)t/(60*60);
}

int TimeGetMM(Time t) {
  //SOLUTION
  return (int)t/60%60;
}

int TimeGetSS(Time t) {
  //SOLUTION
  return (int)t%60;
}

// Get the total seconds since start of day
int TimeGetSeconds(Time t) {
  //SOLUTION
  return (int)t;
}

// String buffer for TimeFormat results.
// CAREFUL! this is overwritten whenever TimeFormat is called!
static char str[9];

// Convert t into a string formatted as "hh:mm:ss".
// CAREFUL: the returned string will be overwritten by the next call.
// You should strcpy or strdup the result if you need persistence!
char* TimeFormat(Time t) {
  snprintf(str, sizeof(str), "%02d:%02d:%02d",
              TimeGetHH(t), TimeGetMM(t), TimeGetSS(t));
  return str;
}

// Parse a time string in the format "hh:mm:ss" and return it,
// or return TimeERR if the string is an invalid time.
// MODIFY the function so that it also accepts times in format "hh:mm".
Time TimeParse(const char* str) {
  //SOLUTION
  Time t = TimeERR;
  int hh, mm, ss;
  ss = 0;  // make sure ss is initialized with default value.
  int n = sscanf(str, "%02d:%02d:%02d", &amp;hh, &amp;mm, &amp;ss);
  if (n &gt;=  2 &amp;&amp; TimeIsValid(hh, mm, ss)) {
    t = TimeCreate(hh, mm, ss);
  }
  assert( t==TimeERR || invariant(t) );  // either TimeERR or ensure the invariant
  return t;
}

// Compare times a and b.
// Return an integer &gt;0 if a&gt;b, 0 if a==b and &lt;0 if a&lt;b.
int TimeCompare(Time a, Time b) {
  //SOLUTION
  return (int)a - (int)b;
}

// Add time a and time b and return a valid time (in 24-hour clock).
// For example: adding 2:30:40 to 23:30:00 should return 02:00:40.
Time TimeAdd(Time a, Time b) {
  // KEEP IT SIMPLE, PLEASE!
  //SOLUTION
  Time t = (a+b)%TimeFULLDAY;
  assert( invariant(t) );  // must ensure the invariant!
  return t;
}

// Subtract time b from time a and return a valid time (in 24-hour clock).
// For example: 2:30:00 minus 4:10:20 should return 22:19:40.
Time TimeSubtract(Time a, Time b) {
  // KEEP IT SIMPLE, PLEASE!
  //SOLUTION
  Time t = (a-b+TimeFULLDAY)%TimeFULLDAY;
  assert( invariant(t) );  // must ensure the invariant!
  return t;
}
</pre>
<p class="caption">TimeInterval.cpp:</p>
<pre>//NMEC: 93097
//NOME: João Gameiro

// Complete the functions (marked by ...)
// so that it passes all tests in DateTimeTest.

#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "TimeInterval.h"

// You may add auxiliary definitions and declarations here, if you need to.





// Every valid instance of a TimeInterval must satisfy this condition.
static int invariant(TimeInterval *ti) {
  return DateTimeCompare(ti-&gt;start, ti-&gt;end) &lt;= 0;
}

// Allocate and init a TimeInterval, given a start and end instant and an ID.
// The start of the interval must precede or equal the end.
// The interval is considered closed-open, [*t1, *t2[, that is,
// the interval contains the start instant, but not the end instant.
// Empty intervals are acceptable.
// The start and end objects are shared with the client,
// but the ID must be copied.
TimeInterval* TimeIntervalCreate(DateTime *t1, DateTime *t2, const char *id) {
  // Fill in the required precondition.
  assert(DateTimeCompare(t1, t2) &lt;= 0);
  TimeInterval* ti = (TimeInterval*)malloc(sizeof *ti);
  if (ti != NULL) {
    ti-&gt;start = t1;
    ti-&gt;end = t2;
    // Create a copy of the id string! Use malloc+strcpy or strdup.
    ti-&gt;id = strdup(id); 
    
  }
  assert (invariant(ti));  // the invariant must be ensured here!
  return ti;
}

// Destroy the TimeInterval instance pointed to by *pti.
// This frees the memory used by **pti and by (*pti)-&gt;id.
// (*pti)-&gt;start and (*pti)-&gt;end should be left untouched.
void TimeIntervalDestroy(TimeInterval **pti) {
  assert (*pti != NULL);
  free((*pti)-&gt;id);   // Free the id field memory
  free(*pti);          // Free the TimeInterval structure memory
  *pti = NULL;
}

// Compare TimeIntervals.
// Return negative if *ti1 ends before *ti2 starts,
// return positive if *ti1 starts after *ti2 ends, and
// return zero if *ti1 and *ti2 overlap.
// NOTE: this does not establish a total order!
// Result=0 does not imply that *ti1 and *ti2 are equal.
int TimeIntervalCompare(TimeInterval *ti1, TimeInterval *ti2) {
  if (DateTimeCompare(ti1-&gt;start, ti2-&gt;start) == 0 &amp;&amp; DateTimeCompare(ti1-&gt;end, ti2-&gt;end) == 0) return 0;
  else if (DateTimeCompare(ti1-&gt;end, ti2-&gt;start) &lt;= 0) return -1;
  else if (DateTimeCompare(ti1-&gt;start, ti2-&gt;end) &gt;= 0) return 1;
  return 0;  

}

// Return true (1) if intervals *ti1 and *ti2 overlap, false otherwise.
int TimeIntervalOverlaps(TimeInterval *ti1, TimeInterval *ti2) {
  return TimeIntervalCompare(ti1, ti2) == 0;
}

// Return true (1) if interval *ti1 contains *ti2, false otherwise.
int TimeIntervalContains(TimeInterval *ti1, TimeInterval *ti2) {
  if((DateTimeCompare(ti1-&gt;start, ti2-&gt;start) &lt;= 0) &amp;&amp; (DateTimeCompare(ti1-&gt;end, ti2-&gt;end) &gt;= 0))
    return 1;
  return 0;

}

// Temporary buffer for TimeIntervalFormat output.
static char buf[256];

char* TimeIntervalFormat(TimeInterval *ti) {
  if (ti==NULL)
    snprintf(buf, sizeof(buf), "NULL");
  else {
    strcpy(buf, "[");
    strcat(buf, DateTimeFormat(ti-&gt;start));
    strcat(buf, ", ");
    strcat(buf, DateTimeFormat(ti-&gt;end));
    strcat(buf, "[(");
    strncat(buf, ti-&gt;id, sizeof(buf) - strlen(buf) - 2);
    strcat(buf, ")");
  }
  return buf;
}

// You may add auxiliary definitions and declarations here, if you need to.


</pre>
</div>
<p class="header providedFiles">Provided files</p>
<div class="providedFiles">
<p class="caption">Date.h:</p>
<pre>#ifndef _DATE_
#define _DATE_

#include &lt;inttypes.h&gt;

struct _date {
  uint16_t year;
  uint8_t month;
  uint8_t day;
};

// The Date type. (To be used in clients.)
typedef struct _date Date;

// Constants
extern const Date DateMIN;
extern const Date DateMAX;

// Macros to select date format
#define YMD 0
#define DMY 1
#define MDY 2


Date* DateCreate(int yy, int mm, int dd) ;
void DateDestroy(Date* *pd) ;
int DateIsValid(int yy, int mm, int dd) ;
int DateDaysInMonth(int yy, int mm) ;
int DateIsLeapYear(int yy) ;
int DateCompare(const Date* a, const Date* b) ;
void DateIncr(Date* d) ;
void DateDecr(Date* d) ;
char* DateFormat(const Date* d, int FMT) ;
Date* DateParse(const char* str, int FMT) ;

#endif //_DATE_
</pre>
<p class="caption">DateTime.h:</p>
<pre>#ifndef _DATETIME_
#define _DATETIME_

#include "Date.h"
#include "Time.h"

typedef struct {
  Date date;
  Time time;
} DateTime;

int DateTimeIsValid(int yy, int mm, int dd, int h, int m, int s) ;
DateTime* DateTimeCreate(int yy, int mm, int dd, int h, int m, int s) ;
void DateTimeDestroy(DateTime **pdt) ;
int DateTimeCompare(DateTime *a, DateTime *b) ;
char *DateTimeFormat(const DateTime *dt) ;
DateTime *DateTimeParse(char *str) ;

#endif
</pre>
<p class="caption">SchedulingSequence.h:</p>
<pre>#ifndef _SCHEDULINGSEQUENCE_
#define _SCHEDULINGSEQUENCE_

#include "TimeInterval.h"

typedef struct {
  int capacity;  // the maximum number capacity of this SchedulingSequence
  int size;      // the number o TimeIntervals stored currently
  TimeInterval **intervals; // points to an array of TimeInterval pointers
} SchedulingSequence;

// Create a SchedulingSequence capable of storing up to (capacity) intervals.
SchedulingSequence* SchedulingSequenceCreate(int capacity) ;

// Destroy SchedulingSequence *pss
void SchedulingSequenceDestroy(SchedulingSequence **pss) ;

int SchedulingSequenceIsEmpty(SchedulingSequence *ss) ;

int SchedulingSequenceIsFull(SchedulingSequence *ss) ;

// Add interval *ti to *ss.
// Return true on success,
// return false if *ti overlaps any of the intervals in *ss.
int SchedulingSequenceAdd(SchedulingSequence *ss, TimeInterval *ti) ;

// Get the interval at position (idx) of *ss.
// idx=0 is the first position idx=ss-&gt;size-1 is the last position.
// Precondition: 0 &lt;= idx &lt; ss-&gt;size.
TimeInterval *SchedulingSequenceGet(SchedulingSequence *ss, int idx) ;

// Remove the interval at position (idx) of *ss, and return it.
// idx=0 is the first position idx=ss-&gt;size-1 is the last position.
// Precondition: 0 &lt;= idx &lt; ss-&gt;size.
TimeInterval *SchedulingSequencePop(SchedulingSequence *ss, int idx) ;

#endif
</pre>
<p class="caption">Time.h:</p>
<pre>#ifndef _TIME_
#define _TIME_

// Time is actually just an integer,
// but it is used to represent a time-of-day.
typedef int Time;

extern const Time TimeMIN, TimeMAX, TimeERR;

Time TimeCreate(int hh, int mm, int ss) ;
int TimeIsValid(int hh, int mm, int ss) ;
int TimeGetHH(Time t) ;
int TimeGetMM(Time t) ;
int TimeGetSS(Time t) ;
int TimeGetSeconds(Time t) ;
char* TimeFormat(Time t) ;
Time TimeParse(const char* str) ;
int TimeCompare(Time a, Time b) ;
Time TimeAdd(Time a, Time b) ;
Time TimeSubtract(Time a, Time b) ;

#endif
</pre>
<p class="caption">TimeInterval.h:</p>
<pre>#ifndef _TIMEINTERVAL_
#define _TIMEINTERVAL_

#include "DateTime.h"

typedef struct {
  DateTime* start;
  DateTime* end;
  char* id;
} TimeInterval;

TimeInterval* TimeIntervalCreate(DateTime *t1, DateTime *t2, const char *id) ;
void TimeIntervalDestroy(TimeInterval **pti) ;
int TimeIntervalCompare(TimeInterval *ti1, TimeInterval *ti2) ;
int TimeIntervalOverlaps(TimeInterval *ti1, TimeInterval *ti2) ;
int TimeIntervalContains(TimeInterval *ti1, TimeInterval *ti2) ;
char* TimeIntervalFormat(TimeInterval *ti) ;

#endif
</pre>
</div>
<p class="header score">Score</p>
<div class="score">
<p class="score">11/11</p>
</div>
<div class="footnotes"><div class="footnote">2020-05-09T22:17:11Z</div>
</div>
</body></html>
